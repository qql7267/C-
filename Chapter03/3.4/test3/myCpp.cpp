#include<iostream>
using namespace std;

/*
C++丰富的类型允许根据需求选择不同的类型
C++自动执行很多类型转化
1.将一种算数类型的值赋给另一种算数类型的变量时 C++将对值进行转换
2.表达式中包含不同的类型时 C++将对值进行转换
3.将参数传递给函数式 C++将对值进行转换
*/

int main()
{
	/*
	C++允许将一种类型的值赋给另一种类型的变量 这样做事 值将被转换为接收变量的类型
	将一个值赋给值取值范围更大的类型通常不会导致什么问题 不会改变这个值 只是会占用的字节贡多而已
	然而将一个很大的long值赋给float变量时 将降低精度
	----------------------------------------------------------------------
	-转换							潜在的问题
	----------------------------------------------------------------------
	-将较大的浮点类型转换为较小的浮点类型	精度(有效数位)降低 值可能超出目标类型的取值范围
	-如将double转换为float			在这种情况下 结果将是不确定的
	----------------------------------------------------------------------
	-将浮点类型转换为整型				小数部分丢失 原来的值可能超出目标类型的取值范围
	-								在这种情况下 结果将是不确定的
	----------------------------------------------------------------------
	-将较大的整型转换为较小的整型			原来的值可能超出目标类型的取值范围 通常只复制右
	-如将long转换为short				边的字节
	----------------------------------------------------------------------
	将0赋给bool变量时 将被转换为false 而非零值将被转换为true
	*/
	cout.setf(ios_base::fixed, ios_base::floatfield);
	float tree = 3;
	int guess = 3.9832;
	int debt = 7.2E12;
	cout << "tree = " << tree << endl;
	cout << "guess = " << guess << endl;
	cout << "debt = " << debt << endl;

	/*
	以{}方式初始化时进行的转换(C++11)
	C++11将使用大括号的初始化称为列表初始化 因为这种初始化常用语给复杂的数据类型提供值列表
	他对类型转换的要求更严格 具体的说 列表初始化不允许缩窄(narrowing) 即变量的类型可能无法表示赋给它的值
	例如 不需要讲浮点型转换为整型 在不同的整型之间的转换或将整型转换为浮点型可能被允许 条件是编译器知道目标变量能够正确的存储赋给它的值
	*/
	const int code = 66;
	int x = 66;
	//char c1{ 31325 };
	char c2 = { 66 };
	char c3{ code };
	//char c4 = { x };
	x = 31325;
	char c5 = x;

	/*
	表达式中的转换
	当同一个表达式中包含两种不同的算数类型时 C++将执行两种自动转换
	首先 一些类型在出现时便会自动转换 其次 有些类型在于其他类型同事出现在表达式中时将被转换
	在计算表达式时 C++将bool、char、ungined char、signed char和short值转换为int
	具体来说 true被转换为1 false被转换为0 这些转换被称为整型提升(integer promotion)
	*/
	short chickens = 20;
	short ducks = 35;
	short fowl = chickens + ducks;
	//程序取得chickens和ducks的值 并将它们转换为int 然后将结果转换为short类型
	/*
	将不同类型进行算术运算时 也会进行一些转换 当运算涉及两种类型时 较小的类型将被转换为较大的类型
	下面是C++11版本的校验表 编译器将以此查阅该列表
	1.如果有一个操作数的类型时long double 则将另一个操作数转换成long double
	2.否则 如果有一个操作数的类型时double 则将另一个操作数转换成double
	3.否则 如果有一个操作数的类型时float 则将另一个操作数转换成float
	4.否则 说明操作数都是整型 因此执行整型提升
	5.在这种情况下 如果两个操作数都是有符号或无符号的 且其中一个操作数的级别比另一个低 则转换为级别高的类型
	6.如果一个操作数为有符号的 另一个操作数为无符号的 且无符号操作数的级别比有符号操作数高 则将有符号操作数转换为无符号操作数所属类型
	7.否则 如果有符号类型可表示无符号类型的所有可能取值 则将无符号操作数转换为有符号操作数所述的类型
	8.否则 将两个操作数都转换为有符号类型的无符号版本
	简单的说 有符号整型按级别从高到低依次为long ling、long、int、short和signed char
	无符号整型的排列顺序与有符号整型相同 
	类型char、signed char和unsigned char的级别相同
	类型bool的级别最低
	wchar_t、chat16_t和char32_t的级别与其底层类型相同
	*/

	/*
	传递参数时的转换
	传递参数时的类型通常有C++函数原型控制
	C++将对char和short类型(signed和unsigned)应对整型提升
	C++将float参数提升为double
	*/

	/*
	强制类型转换
	C++还允许通过强制类型转换机制显式的进行类型转换
	格式有两种
	(typeName)value
	typeName(value)
	强制类型转换不会改变变量本身 而是创建一个新的指定类型的值 可以在表达式中使用这个值
	*/

	int auks, bats, coots;
	auks = 19.99 + 11.99;
	bats = (int)19.99 + (int)11.99;
	coots = int(19.99) + int(11.99);
	cout << "auks = " << auks << ", bats = " << bats << ", coots = " << coots << endl;

	char ch = 'Z';
	cout << "The code for " << ch << " is " << int(ch) << endl;
	//static_cast<>可用于将值从一种数值类型转换为另一种数值类型
	cout << "Yes, the code is " << static_cast<int>(ch) << endl;

	return 0;
}