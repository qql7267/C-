#include <iostream>

int main()
{
	/*
	存储持续性、作用域和链接性
	复习
	自动存储持续性 在函数定义中声明的变量(包括函数参数)的存储持续性为自动的 他们在程序开始执行其所属的函数或代码块时被创建 在执行完函数或代码块时 他们使用的内存被释放 C++有两种存储持续性为自动的变量
	静态存储持续性 在函数定义外定义的变量和使用关键字static定义的变量的存储持续性都为静态 他们在程序整个运行过程中都存在 C++有三种存储持续性为静态的变量
	线程存储持续性(C++11) 程序能够将计算放在可并行处理的不同线程中
	动态存储持续性 用new运算符分配的内存将一直存在 直到使用delete运算符将其释放或程序结束为止 这种内存的存储持续性为动态 有时被称为自动存储或堆
	*/

	/*
	作用域和链接
	作用域描述了名称在文件的多大范围内可见
	链接性描述了名称如何在不同单元内共享
	*/

	/*
	自动存储持续性
	在默认情况下 在函数中声明的函数参数和变量的存储持续性为自动 作用域为局部 没有链接性
	如果在代码块中定义了变量 则该变量的存在时间和作用域将被限制在该代码块内
	如果有两个同名的变量(一个位于外部的代码块中 另一个位于内部代码块中) 程序执行内部代码块中的语句时 将内部代码块中的变量解释为局部代码块变量 新的定义隐藏了以前的定义 新定义可见 旧定义暂时不可见 在程序离开该代码块时 原来的定义又重新可见
	*/

	/*
	静态存储持续性
	静态存储持续性有三种链接性：外部链接性(可在其他文件中访问)、内部链接性(只能再当前文件中访问)和无链接性(只能再当前函数或代码块中访问)
	这三种链接性都在整个程序执行期间存在 与自动变量相比 他们的寿命更长
	由于静态变量的数目在程序运行期间是不变的 因此程序不需要使用特殊的装置(如栈)来管理他们
	编译器将分配固定的内存块来存储所有的静态变量 这些变量在整个程序执行期间一直存在
	如果没有显式的初始化静态变量 编译器将把他设置为0 在默认情况下 静态数组和结构将每个元素或成员的所有位都设置为0
	5种变量存储方式
	------------------------------------------------------------------
	存储描述			持续性	作用域	链接性	如何声明
	------------------------------------------------------------------
	自动				自动		代码块	无		在代码块中
	寄存器			自动		代码块	无		在代码块中 使用关键字register
	静态 无链接性		静态		代码块	无		在代码块中 使用关键字static
	静态 外部链接性	静态		文件		外部		不在任何函数中
	静态 内部链接性	静态		文件		内部		不在任何函数中 使用关键字static
	------------------------------------------------------------------
	*/

	/*
	静态持续性、外部链接性
	链接性为外部的变量通常简称为外部变量 他们的存储持续性为静态 作用域为整个文件
	外部变量是在函数外部定义的 因此多所有函数而言都是外部的 外部变量也称全局变量(相对于局部的自动变量)
	单定义规则
	一方面 在每个使用外部变量的文件中都必须声明他 另一方面 C++有"单定义规则" 即变量只能有一次定义
	为满足这种需求 C++提供了两种变量声明 一种是定义声明或简称为定义 他给变阿玲分配存储空间 另一种是引用声明或简称为声明 他不给变量分配存储空间 因为他引用已有的变量
	引用声明使用关键字extern 且不进行初始化 否则声明为定义 导致分配存储空间
	extern int a1;
	extern int a2 = 1;
	*/

	/*
	静态持续性 内部链接性
	将static限定符用于作用域为整个文件的变量时 改变量的链接性将为内部的
	在多文件程序内 内部链接性和外部链接性之间的差别很有意义 链接性为内部的变量只能在其所属的文件中使用 但常规外部变量都具有外部链接性 即可以外其他文件中使用
	可使用外部变量在多文件程序的不同部分之间共享数据 可使用链接性为内部的静态变量在同一个文件中的多个函数之间共享数据
	另外 如果将作用域为整个文件的变量变为静态的 就不必担心其名称与其他文件中的作用域为整个文件的变量发生冲突
	*/

	/*
	静态存储持续性 无链接性
	将static限定符用于在代码块中定义的变量
	在代码块中使用static时 将导致局部变量的存储持续性为静态的 这意味着虽然该变量只在该代码块中可用 但他在该代码块不处于活动状态时仍然存在 因此在两次函数调用之间 静态局部变量的值爆出不变
	另外 如果初始化了静态局部变量 则呈现只在启动时进行一次初始化 以后再调用函数时 将不会像自动变量那样再次被初始化
	*/

	/*
	说明符和限定符
	有些被称为存储说明符或cv-限定符的C++关键字提供了其他有关存储的信息
	下面是存储说明符
	1.auto(在C++11中不再是说明符) 自动变量(C++11用于自动类型推断)
	2.register 用于在声明中指示寄存器存储 在C++11中 只是显式的指出变量是自动的
	3.static 被作用在作用域为整个文件的声明中时表示内部链接性 被用于局部声明中时表示局部变量的存储持续性是静态的
	4.extern 表明是引用声明 即声明引用在其他地方定义的变量
	5.thread_local(C++11新增的) 指出变量的持续性与其所属的线程的持续性相同
	6.mutable 根据const来解释
	cv-限定符
	1.const 内存被初始化后 程序就不能在对他进行修改
	2.volatile 即使程序代码没有对内存单元进行修改 其值也可能发生变化
	mutable 可以用它来指出 即使结构(或类)变量为const 其某个成员也可以被修改
	struct s
	{
		int a1;
		mutable int a2;
	};
	*/

	/*
	函数和链接性
	函数也有链接性 虽然可选择的范围比变量小
	C和C++不允许在一个函数中定义另一个函数 因此所有函数的存储持续性都自动为静态的 即在整个程序执行期间都一直存在
	在默认情况下 函数的链接性为外部的 即可在文件之间共享
	实际上 可以在函数原型中使用关键字extern来指出函数是在另一个文件中定义的 不过这是可选的
	还可以使用关键字static将函数的链接性设置为内部的 使之只能再一个文件中使用 必须同时在原型和函数定义中使用该关键字
	内联函数不受这项规则的约束 运行程序员将内联函数的定义放在头文件中
	*/

	/*
	语言链接性
	*/

	/*
	存储方案和动态分配
	使用new分配的内存被成文动态内存 不适用于前面分配内存的5种方案(线程内存除外)
	*/

	return 0;
}